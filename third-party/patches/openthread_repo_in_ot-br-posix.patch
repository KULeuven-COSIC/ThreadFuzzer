diff --git a/CMakeLists.txt b/CMakeLists.txt
index c966aa753..fadfb42aa 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -35,6 +35,10 @@ string(STRIP ${OT_DEFAULT_VERSION} OT_DEFAULT_VERSION)
 project(openthread VERSION ${OT_DEFAULT_VERSION})
 include(CTest)
 
+# THREADFUZZ: INCLUDE COMMON DIR (START)
+include_directories(../../../../../common/)
+# THREADFUZZ: INCLUDE COMMON DIR (END)
+
 option(OT_BUILD_EXECUTABLES "Build executables" ON)
 option(OT_COVERAGE "enable coverage" OFF)
 set(OT_EXTERNAL_MBEDTLS "" CACHE STRING "Specify external mbedtls library")
@@ -45,7 +49,7 @@ add_library(ot-config-ftd INTERFACE)
 add_library(ot-config-mtd INTERFACE)
 add_library(ot-config-radio INTERFACE)
 set(CMAKE_CXX_EXTENSIONS OFF)
-set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD 14) # THREADFUZZ: CHANGE CMAKE_CXX_STANDARD FROM 11 to 14
 set(CMAKE_C_STANDARD 99)
 
 message(STATUS "OpenThread Source Directory: ${PROJECT_SOURCE_DIR}")
diff --git a/src/core/coap/coap.cpp b/src/core/coap/coap.cpp
index 38e561858..9fcaaa8fe 100644
--- a/src/core/coap/coap.cpp
+++ b/src/core/coap/coap.cpp
@@ -40,6 +40,22 @@
 #include "net/udp6.hpp"
 #include "thread/thread_netif.hpp"
 
+// THREADFUZZ: INCLUDE SHM (START)
+// #include "shm/shared_memory.h"
+// THREADFUZZ: INCLUDE SHM (END)
+
+// THREADFUZZ: INCLUDE FUZZ_CONFIG (START)
+#include "shm/fuzz_config.h"
+// THREADFUZZ: INCLUDE FUZZ_CONFIG (END)
+
+// THREADFUZZ: EXTERN SHM_G (START)
+// extern std::unique_ptr<SHM> shm_g;
+// THREADFUZZ: EXTERN SHM_G (END)
+
+// THREADFUZZ: EXTERN FUZZ_CONFIG_G (START)
+extern Fuzz_Config fuzz_config_g;
+// THREADFUZZ: EXTERN FUZZ_CONFIG_G (END)
+
 /**
  * @file
  *   This file contains common code base for CoAP client and server.
@@ -178,6 +194,12 @@ Error CoapBase::Send(ot::Message &aMessage, const Ip6::MessageInfo &aMessageInfo
 {
     Error error;
 
+    // THREADFUZZ: COAP INTERCEPTION POINT (START)
+    if (fuzz_config_g.FUZZ_COAP) {
+        otLogNotePlat("CALLING FUZZER AT COAP LEVEL");
+    }
+    // THREADFUZZ: COAP INTERCEPTION POINT (END)
+
 #if OPENTHREAD_CONFIG_OTNS_ENABLE
     Get<Utils::Otns>().EmitCoapSend(AsCoapMessage(&aMessage), aMessageInfo);
 #endif
diff --git a/src/core/common/new.hpp b/src/core/common/new.hpp
index 76d2f5e17..d9be4ff9a 100644
--- a/src/core/common/new.hpp
+++ b/src/core/common/new.hpp
@@ -40,6 +40,9 @@
 
 #include <openthread/platform/toolchain.h>
 
-inline void *operator new(size_t, void *p) throw() { return p; }
+// THREADFUZZ: COMMENT OUT OPENTHREAD's IMPLEMENTATION OF OPERATOR NEW (START)
+// inline void *operator new(size_t, void *p) throw() { return p; }
+#include <memory>
+// THREADFUZZ: COMMENT OUT OPENTHREAD's IMPLEMENTATION OF OPERATOR NEW (END)
 
 #endif // OT_CORE_COMMON_NEW_HPP_
diff --git a/src/core/config/mle.h b/src/core/config/mle.h
index 57e1e507e..14b40f9ae 100644
--- a/src/core/config/mle.h
+++ b/src/core/config/mle.h
@@ -130,7 +130,7 @@
  *
  */
 #ifndef OPENTHREAD_CONFIG_MLE_ATTACH_BACKOFF_ENABLE
-#define OPENTHREAD_CONFIG_MLE_ATTACH_BACKOFF_ENABLE 1
+#define OPENTHREAD_CONFIG_MLE_ATTACH_BACKOFF_ENABLE 0 // THREADFUZZ: CHANGED FROM 1 to 0
 #endif
 
 /**
@@ -232,7 +232,7 @@
  *
  */
 #ifndef OPENTHREAD_CONFIG_MLE_CHILD_ROUTER_LINKS
-#define OPENTHREAD_CONFIG_MLE_CHILD_ROUTER_LINKS 3
+#define OPENTHREAD_CONFIG_MLE_CHILD_ROUTER_LINKS 1 // THREADFUZZ: CHANGED FROM 3 TO 1
 #endif
 
 /**
diff --git a/src/core/thread/mle.cpp b/src/core/thread/mle.cpp
index 8ce0a35d4..81f45bc99 100644
--- a/src/core/thread/mle.cpp
+++ b/src/core/thread/mle.cpp
@@ -59,6 +59,22 @@
 #include "thread/time_sync_service.hpp"
 #include "thread/version.hpp"
 
+// THREADFUZZ: INCLUDE SHM_HELPER (START)
+#include "shm/shm_helper.h"
+// THREADFUZZ: INCLUDE SHM_HELPER (END)
+
+// THREADFUZZ: INCLUDE FUZZ_CONFIG (START)
+#include "shm/fuzz_config.h"
+// THREADFUZZ: INCLUDE FUZZ_CONFIG (END)
+
+// THREADFUZZ: EXTERN SHM_HELPER_G (START)
+extern std::unique_ptr<SHM_Helper> shm_helper_g;
+// THREADFUZZ: EXTERN SHM_HELPER_G (END)
+
+// THREADFUZZ: EXTERN FUZZ_CONFIG_G (START)
+extern Fuzz_Config fuzz_config_g;
+// THREADFUZZ: EXTERN FUZZ_CONFIG_G (END)
+
 using ot::Encoding::BigEndian::HostSwap16;
 
 namespace ot {
@@ -2721,6 +2737,37 @@ void Mle::HandleUdpReceive(Message &aMessage, const Ip6::MessageInfo &aMessageIn
 #endif
 
 exit:
+
+    // THREADFUZZ: MLE INTERCEPTION POINT (START)
+    if (fuzz_config_g.FUZZ_MLE) {
+
+        otLogNotePlat("<<< PACKET RX DETECTED >>>");
+
+        otLogNotePlat("PRESENTING PACKET TO INSPECT");
+        uint16_t payload_offset = aMessage.GetOffset();
+        uint16_t payload_len = aMessage.GetLength() - payload_offset;
+
+        if (payload_len > SHM_MSG_MAX_SIZE) {
+            otLogNotePlat("MESSAGE TOO BIG TO FIT INTO SHARED MEMORY");
+        } else {
+            // TODO: might need an other offset if we need to include the command
+            uint8_t buf[SHM_MSG_MAX_SIZE];
+            uint32_t buf_size = payload_len + 1;
+            aMessage.ReadBytes(payload_offset - 1, buf, buf_size);
+            shm_helper_g->send_mle_msg(PACKET_SRC::SRC_DUT, buf, buf_size);
+            // otLogNotePlat("WROTE MESSAGE TO SHARED MEMORY. SIZE: %u", buf_size);
+            // if (!shm_g->read_bytes(mutex_num, buf, buf_size)) {
+            //     otLogNotePlat("FAILED: READ MESSAGE FROM SHARED MEMORY");
+            // } else {
+            //     otLogNotePlat("SUCCESS: READ MESSAGE FROM SHARED MEMORY. SIZE: %u", buf_size);
+            // }
+        }
+
+        // NOTE: writing back is not necessary for now, the packet is just inspected.
+        otLogNotePlat("CONTROLLER SAYS: INSPECTION DONE");
+    }
+    // THREADFUZZ: MLE INTERCEPTION POINT (END)
+
     // We skip logging failures for broadcast MLE messages since it
     // can be common to receive such messages from adjacent Thread
     // networks.
@@ -4841,6 +4888,46 @@ Error Mle::TxMessage::SendTo(const Ip6::Address &aDestination)
     IgnoreError(Read(offset, securitySuite));
     offset += sizeof(securitySuite);
 
+    // THREADFUZZ: MLE INTERCEPTION POINT (START)
+    if (fuzz_config_g.FUZZ_MLE) {
+
+        otLogNotePlat("CALLING THE FUZZER AT MLE-LAYER");
+
+        // NOTE: when encrypted, we need to write our payload
+        // beyond the security header
+        if (securitySuite == k154Security)
+        {
+            offset += sizeof(SecurityHeader);
+        }
+
+        uint16_t payload_len = this->GetLength() - offset;
+
+        if (payload_len > SHM_MSG_MAX_SIZE) {
+            otLogNotePlat("MESSAGE TOO BIG TO FIT INTO SHARED MEMORY");
+        } else {
+            std::unique_ptr<uint8_t[]> buf(new uint8_t[SHM_MSG_MAX_SIZE]);
+            uint32_t read_buf_size = this->ReadBytes(offset, buf.get(), payload_len);
+            otLogNotePlat("WRITING MESSAGE TO SHARED MEMORY. SIZE: %u: ", read_buf_size);
+            shm_helper_g->send_mle_msg(PACKET_SRC::SRC_PROTOCOL_STACK, buf.get(), read_buf_size);
+            // if (!shm_g->read_bytes(mutex_num, buf.get(), read_buf_size)) {
+            //     otLogNotePlat("FAILED: READ MESSAGE FROM SHARED MEMORY");
+            // } else {
+            otLogNotePlat("SUCCESS: READ MESSAGE FROM SHARED MEMORY. SIZE: %u: ", read_buf_size);
+            uint16_t new_payload_len = read_buf_size;
+            SuccessOrExit(this->SetLength(new_payload_len + offset));
+            this->WriteBytes(offset, buf.get(), new_payload_len);
+            //}
+        }
+
+        // NOTE: here we need to decrease the offset again to make sure
+        // the next part of the code still works!
+        if (securitySuite == k154Security)
+        {
+            offset -= sizeof(SecurityHeader);
+        }
+    }
+    // THREADFUZZ: MLE INTERCEPTION POINT (END)
+
     if (securitySuite == k154Security)
     {
         SecurityHeader header;
diff --git a/src/core/thread/mle.hpp b/src/core/thread/mle.hpp
index 5e7a96087..33910ade1 100644
--- a/src/core/thread/mle.hpp
+++ b/src/core/thread/mle.hpp
@@ -1785,7 +1785,7 @@ private:
 
 #if OPENTHREAD_CONFIG_THREAD_VERSION >= OT_THREAD_VERSION_1_3
     // First attach cycle includes two Parent Requests to routers, followed by four to routers and REEDs.
-    static constexpr uint8_t kFirstAttachCycleTotalParentRequests       = 6;
+    static constexpr uint8_t kFirstAttachCycleTotalParentRequests       = 1; // THREADFUZZ: CHANGED FROM 6 to 1
     static constexpr uint8_t kFirstAttachCycleNumParentRequestToRouters = 2;
 #else
     // First attach cycle in Thread 1.1/1.2 includes a Parent Requests to routers, followed by one to routers and REEDs.
